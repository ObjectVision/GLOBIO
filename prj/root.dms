container GLOBIO
{
	container parameters
	{
		parameter<bool> use_zeroed_initial_alloc_grid := True;
	}
	
	container units
	{
		unit<float32> m   := baseunit('m', float32);
		unit<float32> km  := 1000 * m;
		unit<float32> km2 := km * km;
	}
	
	unit<upoint> world_domain := SourceData/CurrentLanduse/ESA_CCI;
	
	container LandUseTypes
	{
		unit <uint8> types: nrofrows = 6
		{
			attribute<string>  Name:           ['Urban', 'Cropland', 'Pasture', 'RangeLand', 'Forestry', 'other'];
			attribute<string>  NameWithClaims: ['Urban', 'Cropland', 'Pasture', 'Rangeland', 'Forestry'];
			attribute<partitioning> partioning_rel := const(0[partitioning], types);
		}
	}
	
	container Geography
	{
		unit<fpoint> EPSG_4326 : SpatialReference = "EPSG:4326";
		unit<upoint> nl : Range = "[{3, 50}, {8, 54})]";
	}
	
	container SourceData
	{
		container CurrentLanduse
		{
			unit<upoint> ESA_CCI
			:   StorageName = "%SourceDataDir%/GLOBIO/input/ESACCI_GLOBIO_1992_water1992-2015.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			,   StorageReadOnly = "True"
			{    
			   attribute<UInt8> GridData;
			}
		}
		
		container Area
		{
			unit<upoint> Area_km2
			: 	StorageName = "%SourceDataDir%/GLOBIO/input/areakm2_10sec.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			,   StorageReadOnly = "True"
			,   LazyCalculated = "True"
			{
			   attribute<Float32> GridData;
			   attribute<Float32> ReadData(CurrentLanduse/ESA_CCI);
			}
			
			unit<upoint> Protected_areas
			: 	StorageName = "%SourceDataDir%/GLOBIO/input/pa_reduce_factor_wdpa_2018_july.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			,   StorageReadOnly = "True"
			,   LazyCalculated = "True"
			{
			   attribute<Float32> GridData;
			   attribute<Float32> ReadData(CurrentLanduse/ESA_CCI);
			}
		}
		
		container Regions
		{
			unit<upoint> IMAGE
			:   StorageName = "%SourceDataDir%/GLOBIO/input/ESA_IMAGEregions_10sec_no_water_GLOBIO41cz.tif"
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			,   StorageReadOnly = "True"
			{    
			   attribute<regio> GridData;
			   attribute<regio> ReadData(CurrentLanduse/ESA_CCI);
			}
			
			parameter<string> underscore := '_';
			
			unit<uint8> regio 
			: StorageName = "%SourceDataDir%/GLOBIO/input/Regions.csv" // https://models.pbl.nl/image/index.php/Region_classification_map
			, StorageType = "gdal.vect"
			, StorageReadOnly = "True"
			{
				attribute<UInt8>     Code          := UInt8(Nr);
				//attribute<string>    keyUrban      := string(id(.)) + '_Urban';
				attribute<string>    keyString     := string(id(.));
				
				//attribute<units/km2> MaxClaimUrban := rjoin(string(id(.)) + '_Urban', Claims/ClaimTable/key, Claims/ClaimTable/Claim);
				
				
				container keyLandUseType := for_each_nedv(
					LandUseTypes/types/NameWithClaims 
					, 'keyString + underscore +' + quote(LandUseTypes/types/NameWithClaims)
					, regio
					, string
					);
				
				container MaxClaims := for_each_nedv(
					LandUseTypes/types/NameWithClaims 
					,'rjoin(keyLandUseType/' + LandUseTypes/types/NameWithClaims + ', Claims/ClaimTable/key, Claims/ClaimTable/Claim)'
					, regio
					, units/km2
				);
			}	
		}
		
		container Suitabilities
		{
			unit<upoint> Urban
			:   StorageName = "%SourceDataDir%/GLOBIO/input/suit_urban.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			,   LazyCalculated = "True"
			{    
			   attribute<Float32> GridData;
			   attribute<Float32> ReadData(SourceData/CurrentLanduse/ESA_CCI); 
			}
			
			unit<upoint> Pasture
			:   StorageName = "%SourceDataDir%/GLOBIO/input/suit_pasture_lu_diff_no_wtr.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			{    
			   attribute<Float32> GridData;
			   attribute<Float32> ReadData(SourceData/CurrentLanduse/ESA_CCI); 
			}
			
			unit<upoint> Cropland
			:   StorageName = "%SourceDataDir%/GLOBIO/input/suit_crop_lu_diff_no_wtr_ice_0.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			{    
			   attribute<Float32> GridData;
			   attribute<Float32> ReadData(SourceData/CurrentLanduse/ESA_CCI); 
			}
			
			unit<upoint> Forestry
			:   StorageName = "%SourceDataDir%/GLOBIO/input/suit_forestry_2015.tif" 
			,   StorageType = "gdal.grid" 
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			, 	SpatialReference = "Geography/EPSG_4326"
			{    
			   attribute<Float32> GridData;
			   attribute<Float32> ReadData(SourceData/CurrentLanduse/ESA_CCI); 
			}
			
			unit<upoint> NotAllocatable
			:   StorageName = "%SourceDataDir%/GLOBIO/input/not_allocatable_ESA-CCI_1992-2015.tif"
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			//,   StorageType = "gdal.grid"
			, 	SpatialReference = "Geography/EPSG_4326"
			{    
			   attribute<Bool> GridData;
			   attribute<Bool> ReadData(SourceData/CurrentLanduse/ESA_CCI); 
			}
			
			unit<upoint> NotAllocatable1
			:   StorageName = "%SourceDataDir%/GLOBIO/input/not_allocatable_ESA-CCI_1992-2015.tif"
			,   DialogData  = "Geography/EPSG_4326" 
			,   DialogType  = "Map"
			//,   StorageType = "gdal.grid"
			, 	SpatialReference = "Geography/EPSG_4326"
			{    

			}
		}
	}

	container Suitabilities : LazyCalculated = "True"
	{
		attribute<Float32> Urban(world_domain)    := SourceData/Suitabilities/Urban/ReadData;
		attribute<Float32> Pasture(world_domain)  := SourceData/Suitabilities/Pasture/ReadData;
		attribute<Float32> Cropland(world_domain) := SourceData/Suitabilities/Cropland/ReadData;
		attribute<Float32> Forestry(world_domain) := SourceData/Suitabilities/Forestry/ReadData;
	}
	
	container Claims
	{
		unit<uint8> ClaimTable
		:   StorageName = "%SourceDataDir%/GLOBIO/input/Claim1970.csv" 
		,   StorageType = "gdal.vect"
		,   StorageReadOnly = "True"
		{
			attribute<uint8>     Region;
			attribute<string>    Class   := Attribute;
			attribute<units/km2> Claim   := Value[units/km2];
			attribute<string>    key     := String(Region) + '_' + Class;
		}
		
		attribute<float32> scale_factors (SourceData/Regions/regio) := mean(SourceData/area/Area_km2/ReadData, SourceData/Regions/IMAGE/ReadData);
		
		container test
		{
			parameter<string> underscore := '_';
			attribute<string>    keyString (SourceData/Regions/regio) := string(id(SourceData/Regions/regio));

			container keyLandUseType := for_each_nedv(
			LandUseTypes/types/NameWithClaims 
				, 'keyString + underscore +' + quote(LandUseTypes/types/NameWithClaims)
				, SourceData/Regions/regio
				, string
			);

			container MaxClaims := for_each_nedv(
			LandUseTypes/types/NameWithClaims 
				,'rjoin(keyLandUseType/' + LandUseTypes/types/NameWithClaims + ', Claims/ClaimTable/key, Claims/ClaimTable/Claim)'
				, SourceData/Regions/regio
				, units/km2
			)
			{
				attribute<uint32> Other (SourceData/Regions/regio) := pcount(Compacted/regio_rel);
			}
			
			container MaxClaimsScaled := for_each_nedv(
				  LandUseTypes/types/NameWithClaims
				, 'UInt32(MaxClaims/' + LandUseTypes/types/NameWithClaims  + '/ scale_factors[units/km2])'
				, SourceData/Regions/regio
				, uint32
			
			)
			{
				attribute<uint32> Other (SourceData/Regions/regio) := MaxClaims/Other;
			}
		}		
	}
	
	container Compacted
	{
		attribute<Bool> compact_condition(world_domain) := not(SourceData/Suitabilities/NotAllocatable/ReadData);
		unit<uint32> alloc_domain := select_uint32(compact_condition), label = "allocation domain", DialogType = "Map", DialogData = "BaseGrid";
		attribute<alloc_domain> BaseGrid(world_domain) := recollect_by_cond(compact_condition, id(alloc_domain));

		attribute<uint8> alloc_grid (alloc_domain) := collect_by_cond(alloc_domain, compact_condition, SourceData/CurrentLanduse/ESA_CCI/GridData);

		attribute<Float32> Protected_areas_compacted (alloc_domain) := collect_by_cond(alloc_domain, compact_condition, SourceData/Area/Protected_areas/ReadData);
		container SuitabilityMaps
		{
			attribute<Int32> Urban(alloc_domain)     := (collect_by_cond(alloc_domain, compact_condition, Suitabilities/Urban)    * Protected_areas_compacted * 1000000.0f)[Int32];
			attribute<Int32> Pasture(alloc_domain)   := (collect_by_cond(alloc_domain, compact_condition, Suitabilities/Pasture)  * Protected_areas_compacted * 1000000.0f)[Int32];
			attribute<Int32> Cropland(alloc_domain)  := (collect_by_cond(alloc_domain, compact_condition, Suitabilities/Cropland) * Protected_areas_compacted * 1000000.0f)[Int32];
			attribute<Int32> Forestry(alloc_domain)  := (collect_by_cond(alloc_domain, compact_condition, Suitabilities/Forestry) * Protected_areas_compacted * 1000000.0f)[Int32];
			attribute<Int32> RangeLand(alloc_domain) := Pasture;
			attribute<Int32> Other(alloc_domain)     := const(1i, alloc_domain);
		}
		
		attribute<SourceData/Regions/regio> regio_rel (alloc_domain) := collect_by_cond(alloc_domain, compact_condition, SourceData/Regions/IMAGE/ReadData);
	}
	
	container FeasibleSolution;
	
	container Templates
	{
		Template AllocateSteppedLanduse
		{
			// begin case parameters
			parameter<string> landuse_name;
			parameter<uint8>  landuse_code;
			attribute<uint8>  alloc_grid (alloc_domain);
			attribute<bool>   suitability_augmentation_mask (alloc_domain);
			// end case parameters

			unit<uint8> AtomicRegions := SourceData/Regions/regio
			{
				attribute<.> regio := id(.);
			}
			
			container SuitabilityMaps
			{
				attribute<int32> alloc(alloc_domain) :== 'Compacted/SuitabilityMaps/' + landuse_name +'*suitability_augmentation_mask[int32]';
				attribute<int32> other(alloc_domain) := Compacted/SuitabilityMaps/Other;
			}
			
			container SteppedClaims
			{
				container Minimum
				{
					Attribute<UInt32> alloc (SourceData/Regions/regio) := const(0, SourceData/Regions/regio);
					Attribute<UInt32> other (SourceData/Regions/regio) := const(0, SourceData/Regions/regio);
				}
				
				container Maximum
				{
					Attribute<UInt32> alloc (SourceData/Regions/regio) :== 'Claims/test/MaxClaimsScaled/' + landuse_name;
					Attribute<UInt32> other (SourceData/Regions/regio) :=   Claims/test/MaxClaimsScaled/Other; ///Claims/Direct/Maximum/Other;
				}
			}
			
			container allocate_step := 
			discrete_alloc(
			Allocation/allocate_stepwise/lu_type/name
			,Compacted/alloc_domain
			,SuitabilityMaps
			,Allocation/allocate_stepwise/lu_type/partioning_rel
			,Allocation/partitioning/Name
			,Allocation/AtomicRegions
			,Compacted/regio_rel
			,SteppedClaims/Minimum
			,SteppedClaims/Maximum
			,0i
			,FeasibleSolution
			)
			{
				attribute<Allocation/allocate_stepwise/lu_type> alloc(world_domain) := landuse[Compacted/BaseGrid];
			}
			
			attribute<uint8> adjusted_alloc_grid (alloc_domain) := (allocate_step/landuse==0b) ? landuse_code : alloc_grid;
			attribute<Bool> new_suitability_augmentation_mask (alloc_domain) := suitability_augmentation_mask || not(allocate_step/landuse);
		}
	}
	
	container Allocation
	{
		unit<uint8> AtomicRegions := SourceData/Regions/regio
		{
			attribute<.> regio := id(.);
		}
	
		unit <uint8> partitioning: nrofrows = 1
		{
			attribute<String> Name : ['regio'];
		}
	
		container allocate_stepwise
		{
			unit<uint32> alloc_domain := Compacted/alloc_domain;
			unit <uint8> lu_type: nrofrows = 2
			{
				attribute<string>  Name:           ['alloc', 'other'];
				attribute<partitioning> partioning_rel := const(0[partitioning], lu_type);
			}
			
			attribute<uint8> initial_alloc_grid (alloc_domain) := parameters/use_zeroed_initial_alloc_grid ? const(0b, alloc_domain) : Compacted/alloc_grid;
			container Urban_t     := Templates/AllocateSteppedLanduse("Urban",      1b, initial_alloc_grid,            const(True, alloc_domain));
			container Cropland_t  := Templates/AllocateSteppedLanduse("Cropland",  10b, Urban_t/adjusted_alloc_grid,     Urban_t/new_suitability_augmentation_mask), ExplicitSuppliers='Urban_t';
			container Forestry_t  := Templates/AllocateSteppedLanduse("Forestry",  30b, Cropland_t/adjusted_alloc_grid,  Cropland_t/new_suitability_augmentation_mask), ExplicitSuppliers='Cropland_t';
			container Pasture_t   := Templates/AllocateSteppedLanduse("Pasture",   21b, Forestry_t/adjusted_alloc_grid,  Forestry_t/new_suitability_augmentation_mask), ExplicitSuppliers='Forestry_t';
			container Rangeland_t := Templates/AllocateSteppedLanduse("Rangeland", 22b, Pasture_t/adjusted_alloc_grid, Pasture_t/new_suitability_augmentation_mask), ExplicitSuppliers='Pasture_t';

			attribute<uint8> landuse (world_domain) := Rangeland_t/adjusted_alloc_grid[Compacted/BaseGrid];
		}
		
		container allocate_discrete
		{
			container allocate := 
			discrete_alloc(
			LandUseTypes/types/name
			,Compacted/alloc_domain
			,Compacted/SuitabilityMaps
			,LandUseTypes/types/partioning_rel
			,Allocation/partitioning/Name
			,Allocation/AtomicRegions
			,Compacted/regio_rel
			,Claims/Direct/Minimum
			,Claims/Direct/Maximum
			,0i
			,FeasibleSolution
			)
			{
				attribute<LandUseTypes/types> alloc(world_domain) := landuse[Compacted/BaseGrid];
			}
		}
	}
	
	container Export
	{
		parameter<string> generate := "Ok", ExplicitSuppliers='allocated_landuse_stepped/GridData';
		
		unit<upoint> allocated_landuse_stepped := world_domain
		, StorageName       = "%SourceDataDir%/GLOBIO/output/geodms_stepped_allocation.tif" 
		, StorageType       = "gdalwrite.grid"
		, DialogData        = "Geography/EPSG_4326"
		, DialogType        = "Map"
		, SpatialReference  = "Geography/EPSG_4326"
		, ExplicitSuppliers = "Allocation/allocate_stepwise/Rangeland_t/adjusted_alloc_grid"
		, StorageReadOnly   = "False"
		{
		   attribute<uint8> GridData := Allocation/allocate_stepwise/landuse, Descr="Geography/EPSG_4326";
		}
		
		unit<upoint> allocated_landuse_discrete := world_domain
		, StorageName = "%SourceDataDir%/GLOBIO/output/geodms_discrete_allocation.tif"
		, StorageType = "tif" //"gdalwrite.grid"
		, StorageReadOnly = "False"
		{
		   attribute<uint8> GridData := Allocation/allocate_discrete/allocate/landuse[Compacted/BaseGrid];
		}
	}
	
	container Evaluate
	{
		container reference
		{
			unit<upoint> globio_world
			: StorageName = "%SourceDataDir%/GLOBIO/output/world/Globio4_landuse_10sec_1970_World.tif" 
			, StorageType = "gdal.grid"
			, DialogData        = "Geography/EPSG_4326"
			, DialogType        = "Map"
			, StorageReadOnly = "True"
			{
				attribute<uint8> GridData;
				attribute<uint8> ReadData (SourceData/CurrentLanduse/ESA_CCI);
			}
		}
		
		container stepped
		{
			unit<upoint> dms_world := SourceData/CurrentLanduse/ESA_CCI
			, StorageName = "%SourceDataDir%/GLOBIO/output/geodms_stepped_allocation.tif" 
			, StorageType = "gdal.grid"
			, DialogData        = "Geography/EPSG_4326"
			, DialogType        = "Map"
			, StorageReadOnly = "True"
			{
				attribute<uint8> GridData;
			}
		}
		
		container discrete
		{
		}
		
		container indicators 
		{
			unit<uint8> Urban := SourceData/Regions/regio
			, StorageName = "%SourceDataDir%/GLOBIO/output/alloc_differences_urban.csv" 
				, StorageType = "gdalwrite.vect"
				, StorageReadOnly = "False"
			{
				attribute<float32> globio_num_urban_cells := sum(float32(reference/globio_world/ReadData) * float32(reference/globio_world/ReadData==1b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> dms_num_urban_cells    := sum(float32(stepped/dms_world/GridData) * float32(stepped/dms_world/GridData==1b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> fraction               := globio_num_urban_cells / dms_num_urban_cells;
				attribute<float32> difference             := globio_num_urban_cells - dms_num_urban_cells;
			}
			
			unit<uint8> Cropland := SourceData/Regions/regio
			, StorageName = "%SourceDataDir%/GLOBIO/output/alloc_differences_urban.csv" 
				, StorageType = "gdalwrite.vect"
				, StorageReadOnly = "False"
			{
				attribute<float32> globio_num_urban_cells := sum(float32(reference/globio_world/ReadData) * float32(reference/globio_world/ReadData==10b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> dms_num_urban_cells    := sum(float32(stepped/dms_world/GridData) * float32(stepped/dms_world/GridData==10b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> fraction               := globio_num_urban_cells / dms_num_urban_cells;
				attribute<float32> difference             := globio_num_urban_cells - dms_num_urban_cells;
			}
			
			unit<uint8> Forestry := SourceData/Regions/regio
			, StorageName = "%SourceDataDir%/GLOBIO/output/alloc_differences_urban.csv" 
				, StorageType = "gdalwrite.vect"
				, StorageReadOnly = "False"
			{
				attribute<float32> globio_num_urban_cells := sum(float32(reference/globio_world/ReadData) * float32(reference/globio_world/ReadData==30b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> dms_num_urban_cells    := sum(float32(stepped/dms_world/GridData) * float32(stepped/dms_world/GridData==30b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> fraction               := globio_num_urban_cells / dms_num_urban_cells;
				attribute<float32> difference             := globio_num_urban_cells - dms_num_urban_cells;
			}
			
			unit<uint8> Pasture := SourceData/Regions/regio
			, StorageName = "%SourceDataDir%/GLOBIO/output/alloc_differences_urban.csv" 
				, StorageType = "gdalwrite.vect"
				, StorageReadOnly = "False"
			{
				attribute<float32> globio_num_urban_cells := sum(float32(reference/globio_world/ReadData) * float32(reference/globio_world/ReadData==21b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> dms_num_urban_cells    := sum(float32(stepped/dms_world/GridData) * float32(stepped/dms_world/GridData==21b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> fraction               := globio_num_urban_cells / dms_num_urban_cells;
				attribute<float32> difference             := globio_num_urban_cells - dms_num_urban_cells;
			}
			
			unit<uint8> Rangeland := SourceData/Regions/regio
			, StorageName = "%SourceDataDir%/GLOBIO/output/alloc_differences_urban.csv" 
				, StorageType = "gdalwrite.vect"
				, StorageReadOnly = "False"
			{
				attribute<float32> globio_num_urban_cells := sum(float32(reference/globio_world/ReadData) * float32(reference/globio_world/ReadData==22b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> dms_num_urban_cells    := sum(float32(stepped/dms_world/GridData) * float32(stepped/dms_world/GridData==22b), SourceData/Regions/IMAGE/ReadData);
				attribute<float32> fraction               := globio_num_urban_cells / dms_num_urban_cells;
				attribute<float32> difference             := globio_num_urban_cells - dms_num_urban_cells;
			}
			
		}
	}
}