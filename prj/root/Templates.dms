container Templates
{
	Template MakeGrid_t {
		attribute<LandUseType> landuse(domain);			
		parameter<string> OutputFileName;
		
		attribute<LandUseCode> LandUseCode_rel (domain) := landuse->LandUseCode_rel;
		
		attribute<LandUseCode> result(world_domain) := recollect_by_cond(Compacted/compact_condition, LandUseCode_rel)
		, StorageName = "='%GlobioSourceDataDir%/output/'+OutputFileName+'.TIF'"
		, StorageType       = "gdalwrite.grid"
		, DialogData        = "Geography/EPSG_4326";
	}
	
	Template AllocateWeightedNthElement
	{
		// begin case parameters
		parameter<LanduseType>  CurrLanduseType_rel;
		attribute<LanduseType>  org_alloc_state(domain);
		// end case parameters
		
		parameter<string> landuse_name := CurrLanduseType_rel->name;
		
		attribute<Bool> suitability_augmentation_mask (domain) := org_alloc_state == LandUseType/V/other;
		
		attribute<int32> OrgSuitabilityMap(domain) := ='Compacted/SuitabilityMaps/' + landuse_name;
		attribute<int32> SuitabilityMap(domain) := suitability_augmentation_mask ? OrgSuitabilityMap : -1i, LazyCalculated = "True";
		
		attribute<int32> Rank(domain) := - SuitabilityMap, LazyCalculated = "True";
		
		Attribute<Float32> AreaClaim (SourceData/Regions/regio) := ='Claims/Area/' + landuse_name;
			
		attribute<int32> zaaglijn_org (SourceData/Regions/regio) := Nth_element_weighted(Rank, float64(AreaClaim), float64(Compacted/Area), Compacted/regio_rel);
		attribute<int32> zaaglijn(SourceData/Regions/regio) := Min_elem(zaaglijn_org, -1i32), KeepData = "True";
		
		attribute<bool>  allocate(domain) := Rank < zaaglijn[Compacted/regio_rel], LazyCalculated = "True";
		attribute<LanduseType> adjusted_alloc_state(domain) := allocate ? CurrLanduseType_rel : org_alloc_state, LazyCalculated = "True";
		
		attribute<uint32>  sum_per_regio (SourceData/Regions/regio) := sum_uint32(allocate, Compacted/regio_rel);
		attribute<units/km2> area_allocated (domain) := allocate ? Compacted/area : 0[units/km2], LazyCalculated = "True";
		attribute<float32> area_per_regio (SourceData/Regions/regio) := sum(area_allocated, Compacted/regio_rel);
	}
	
	Template SteppedAllocateLanduse
	{
		// begin case parameters
		parameter<LanduseType>  CurrLanduseType_rel;
		attribute<LanduseType>  org_alloc_state(domain);
		// end case parameters
		
		parameter<string> landuse_name := CurrLanduseType_rel->name;
		
		attribute<Bool> suitability_augmentation_mask (domain) := org_alloc_state == LandUseType/V/other;
		
		attribute<int32> OrgSuitabilityMap(domain) := = 'Compacted/SuitabilityMaps/' + landuse_name;
		attribute<int32> SuitabilityMap(domain) := suitability_augmentation_mask ? OrgSuitabilityMap : -1i, LazyCalculated = "True";
		
		container SuitabilityMaps
		{
			attribute<int32> alloc(domain) := SuitabilityMap;
			attribute<int32> other(domain) := const(0i, domain);
		}
		
		container SteppedClaims
		{
			Attribute<UInt32> alloc (SourceData/Regions/regio) :== 'Claims/Scaled/' + landuse_name;
			Attribute<UInt32> other (SourceData/Regions/regio) := const(0, SourceData/Regions/regio);
		}
		
		container allocate_step := discrete_alloc(alloc_type/name
			,domain
			,SuitabilityMaps
			,alloc_type/partioning_rel
			,partitioning/Name
			,AtomicRegions
			,Compacted/regio_rel
			,SteppedClaims ,SteppedClaims
			,0i
			,FeasibleSolution
		)
		{
			
		}

		attribute<bool>  allocate(domain) := (allocate_step/landuse==0b), LazyCalculated = "True";
		attribute<LanduseType> adjusted_alloc_state(domain) := allocate ? CurrLanduseType_rel : org_alloc_state, LazyCalculated = "True";
		
		attribute<uint32>  sum_per_regio (SourceData/Regions/regio) := sum_uint32(allocate, Compacted/regio_rel);
		attribute<units/km2> area_allocated (domain) := allocate ? Compacted/area : 0[units/km2], LazyCalculated = "True";
		attribute<float32> area_per_regio (SourceData/Regions/regio) := sum(area_allocated, Compacted/regio_rel);
	}
	
	Template MakeCompactedRegionDomain
	{
		// begin case parameters
		parameter<uint8>  region;
		// end case parameters
		
		parameter<string> region_name := /SourceData/Regions/regio/Label[region];
		
		attribute<Bool> compact_condition(Geography/world_domain) := and(not(SourceData/Suitabilities/NotAllocatable/ReadData), SourceData/Regions/IMAGE/ReadData==region);
		unit<uint32> domain := select_uint32(compact_condition), DialogType = "Map", DialogData = "BaseGrid"
		{
			attribute<int64> ordinal(.) := collect_by_cond(domain, compact_condition, Geography/world_domain/ordinal);
		}
		attribute<domain> BaseGrid(Geography/world_domain) := recollect_by_cond(compact_condition, id(domain));

		attribute<LandUseCode> CurrentLandUseCode (domain) := collect_by_cond(domain, compact_condition, SourceData/CurrentLanduse/ESA_CCI/GridData);

		attribute<units/km2> area(domain)  := collect_by_cond(domain, compact_condition, SourceData/area/ReadData)[units/km2];
		
		attribute<Float32> UsageReductionFactor (domain) := collect_by_cond(domain, compact_condition, SourceData/UsageReductionFactor/ReadData);
		
		container SuitabilityMaps // implement integrity check not larger than 1.0
		{
			attribute<int32> plateau_augmentation_factor (domain) := int32(mod(uint32(id(domain)), uint32(pow(2f,10f))));
			parameter<float32> SuitStepFactor := pow(2.0f, 20.0f);
			attribute<Int32> Urban(domain)     := int32(collect_by_cond(domain, compact_condition, Suitabilities/Urban)    * UsageReductionFactor * SuitStepFactor) + plateau_augmentation_factor;
			attribute<Int32> Pasture(domain)   := int32(collect_by_cond(domain, compact_condition, Suitabilities/Pasture)  * UsageReductionFactor * SuitStepFactor) + plateau_augmentation_factor;
			attribute<Int32> Cropland(domain)  := int32(collect_by_cond(domain, compact_condition, Suitabilities/Cropland) * UsageReductionFactor * SuitStepFactor) + plateau_augmentation_factor;
			attribute<Int32> Forestry(domain)  := int32(collect_by_cond(domain, compact_condition, Suitabilities/Forestry) * UsageReductionFactor * SuitStepFactor) + plateau_augmentation_factor;
			attribute<Int32> RangeLand(domain) := Pasture;
			attribute<Int32> Other(domain)     := const(0i, domain) + plateau_augmentation_factor;
		}
		
		attribute<SourceData/Regions/regio> regio_rel (domain) := collect_by_cond(domain, compact_condition, SourceData/Regions/IMAGE/ReadData);
		
		parameter<bool> use_zeroed_initial_alloc_grid := True; // necessary for nth-element allocation
		attribute<LandUseType> initial_alloc_state(domain) := = use_zeroed_initial_alloc_grid ? 'const(LandUseType/V/other, domain)' : 'CurrentLandUseCode->LandUseType_rel';
	}
}